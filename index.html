<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Analyzer</title>
    <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            text-align: center;
        }
        #inputData {
            width: 400px;
            height: 150px;
            padding: 10px;
            margin: 10px;
            font-size: 16px;
        }
        #submitBtn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #mynetwork {
            width: 100%;
            height: 600px;
            border: 1px solid lightgray;
            margin-top: 20px;
        }
        #output {
            margin-top: 20px;
            font-size: 16px;
            text-align: left;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }
        .stat-section {
            margin-bottom: 25px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 15px;
        }
        h3 {
            color: #2a4d69;
        }
    </style>
</head>
<body>
    <h1>Network Analyzer</h1>
    <textarea id="inputData" placeholder="Î•Î¹ÏƒÎ¬Î³ÎµÏ„Îµ Î´ÎµÎ´Î¿Î¼Î­Î½Î± ÏƒÏ‡Î­ÏƒÎµÏ‰Î½ (Ï€.Ï‡. ÎŸÎÎŸÎœÎ‘1,ÎŸÎÎŸÎœÎ‘2,Î£Î§Î•Î£Î—,Î’Î‘Î¡ÎŸÎ£)"></textarea><br>
    <button id="submitBtn">Î‘Î½Î¬Î»Ï…ÏƒÎ· & ÎŸÏ€Ï„Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ·</button>
    <div id="mynetwork"></div>
    <div id="output"></div>

    <script>
        const inputData = document.getElementById('inputData');
        const submitBtn = document.getElementById('submitBtn');
        const output = document.getElementById('output');
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let network;

        submitBtn.addEventListener('click', function() {
            const data = inputData.value.trim();
            if (data) {
                processNetwork(data);
            } else {
                output.textContent = "Î Î±ÏÎ±ÎºÎ±Î»Ï ÎµÎ¹ÏƒÎ¬Î³ÎµÏ„Îµ Î´ÎµÎ´Î¿Î¼Î­Î½Î±!";
            }
        });

        function processNetwork(data) {
            nodes.clear();
            edges.clear();
            const nodeMap = new Map();
            const relationships = data.split('\n').map(line => line.split(',').map(part => part.trim()));

            relationships.forEach(([from, to, type, weight]) => {
                if (from && to && weight) {
                    if (!nodeMap.has(from)) {
                        nodeMap.set(from, nodes.length);
                        nodes.add({ id: nodeMap.get(from), label: from, group: 0 });
                    }
                    if (!nodeMap.has(to)) {
                        nodeMap.set(to, nodes.length);
                        nodes.add({ id: nodeMap.get(to), label: to, group: 0 });
                    }
                    edges.add({
                        from: nodeMap.get(from),
                        to: nodeMap.get(to),
                        label: `${type} (${parseFloat(weight).toFixed(2)})`,
                        width: parseFloat(weight) * 3
                    });
                }
            });

            const communities = detectCommunities(nodeMap, edges);
            nodes.update(communities);

            const container = document.getElementById('mynetwork');
            const networkData = { nodes: nodes, edges: edges };
            const options = {
                nodes: { shape: 'dot', size: 20, font: { size: 16, face: 'Arial' } },
                edges: { font: { size: 12 }, color: 'gray' },
                physics: { forceAtlas2Based: { gravitationalConstant: -50, centralGravity: 0.01 } },
                layout: { improvedLayout: true }
            };
            network = new vis.Network(container, networkData, options);

            analyzeNetwork(nodeMap, edges);
        }

        function detectCommunities(nodeMap, edges) {
            const communityMap = new Map();
            let group = 0;
            const visited = new Set();

            edges.forEach(edge => {
                const from = edge.from;
                const to = edge.to;
                if (!visited.has(from) && !visited.has(to)) {
                    group++;
                    visited.add(from);
                    visited.add(to);
                    communityMap.set(from, group);
                    communityMap.set(to, group);
                } else if (visited.has(from)) {
                    communityMap.set(to, communityMap.get(from));
                    visited.add(to);
                } else if (visited.has(to)) {
                    communityMap.set(from, communityMap.get(to));
                    visited.add(from);
                }
            });

            return nodes.get().map(node => ({
                id: node.id,
                group: communityMap.get(node.id) || 0
            }));
        }

        function analyzeNetwork(nodeMap, edges) {
            const nodeCount = nodes.length;
            const edgeCount = edges.length;
            const degreeCentrality = new Map();

            edges.forEach(edge => {
                degreeCentrality.set(edge.from, (degreeCentrality.get(edge.from) || 0) + 1);
                degreeCentrality.set(edge.to, (degreeCentrality.get(edge.to) || 0) + 1);
            });

            const density = (2 * edgeCount) / (nodeCount * (nodeCount - 1));
            const topNodes = Array.from(degreeCentrality.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([id, degree]) => `${nodes.get(id).label}: ${degree}`);

            const closeness = calcCloseness();
            const betweenness = calcBetweenness();
            const pagerank = calcPageRank();

            const suggestions = suggestFriends(nodeMap, edges);

            output.innerHTML = `
                <div class="stat-section">
                    <h3>ğŸ“Š Î’Î±ÏƒÎ¹ÎºÎ¬ Î£Ï„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬</h3>
                    ÎšÏŒÎ¼Î²Î¿Î¹: ${nodeCount}<br>
                    Î£Ï…Î½Î´Î­ÏƒÎµÎ¹Ï‚: ${edgeCount}<br>
                    Î Ï…ÎºÎ½ÏŒÏ„Î·Ï„Î± Î”Î¹ÎºÏ„ÏÎ¿Ï…: ${density.toFixed(4)}<br>
                </div>
                <div class="stat-section">
                    <h3>ğŸŒŸ ÎŸÎ¹ 5 Î Î¹Î¿ ÎšÎµÎ½Ï„ÏÎ¹ÎºÎ¿Î¯ ÎšÏŒÎ¼Î²Î¿Î¹ (Degree)</h3>
                    ${topNodes.join('<br>')}
                    <p><i>Degree Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï€ÏŒÏƒÎµÏ‚ Î¬Î¼ÎµÏƒÎµÏ‚ ÏƒÏ…Î½Î´Î­ÏƒÎµÎ¹Ï‚ Î­Ï‡ÎµÎ¹ Î­Î½Î±Ï‚ ÎºÏŒÎ¼Î²Î¿Ï‚. ÎŒÏƒÎ¿ Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ¿, Ï„ÏŒÏƒÎ¿ Ï€Î¹Î¿ Â«Î´Î·Î¼Î¿Ï†Î¹Î»Î®Ï‚Â» Î¿ ÎºÏŒÎ¼Î²Î¿Ï‚.</i></p>
                </div>
                <div class="stat-section">
                    <h3>ğŸ”€ Betweenness Centrality</h3>
                    ${formatMap(betweenness)}
                    <p><i>Betweenness Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï€Î¿Î¹Î¿Î¹ ÎºÏŒÎ¼Î²Î¿Î¹ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¿ÏÎ½ Ï‰Ï‚ Â«Î³Î­Ï†Ï…ÏÎµÏ‚Â» Î±Î½Î¬Î¼ÎµÏƒÎ± ÏƒÎµ Î¿Î¼Î¬Î´ÎµÏ‚. Î¥ÏˆÎ·Î»Î® Ï„Î¹Î¼Î® ÏƒÎ·Î¼Î±Î¯Î½ÎµÎ¹ ÏŒÏ„Î¹ Î¿ ÎºÏŒÎ¼Î²Î¿Ï‚ ÎµÎ»Î­Î³Ï‡ÎµÎ¹ Ï„Î· ÏÎ¿Î® Ï€Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯Î±Ï‚.</i></p>
                </div>
                <div class="stat-section">
                    <h3>ğŸ“ Closeness Centrality</h3>
                    ${formatMap(closeness)}
                    <p><i>Closeness Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï€ÏŒÏƒÎ¿ Î³ÏÎ®Î³Î¿ÏÎ± Î¼Ï€Î¿ÏÎµÎ¯ Î­Î½Î±Ï‚ ÎºÏŒÎ¼Î²Î¿Ï‚ Î½Î± Ï†Ï„Î¬ÏƒÎµÎ¹ ÏŒÎ»Î¿Ï…Ï‚ Ï„Î¿Ï…Ï‚ Î¬Î»Î»Î¿Ï…Ï‚. ÎŒÏƒÎ¿ Ï€Î¹Î¿ Ï…ÏˆÎ·Î»ÏŒ, Ï„ÏŒÏƒÎ¿ Ï€Î¹Î¿ Â«ÎºÎµÎ½Ï„ÏÎ¹ÎºÏŒÏ‚Â» ÏƒÏ„Î¿ Î´Î¯ÎºÏ„Ï…Î¿.</i></p>
                </div>
                <div class="stat-section">
                    <h3>ğŸ† PageRank</h3>
                    ${formatMap(pagerank)}
                    <p><i>PageRank Î¼ÎµÏ„ÏÎ¬ Ï„Î· Â«ÏƒÎ·Î¼Î±ÏƒÎ¯Î±Â» ÎµÎ½ÏŒÏ‚ ÎºÏŒÎ¼Î²Î¿Ï…, Î»Î±Î¼Î²Î¬Î½Î¿Î½Ï„Î±Ï‚ Ï…Ï€ÏŒÏˆÎ· ÏŒÏ‡Î¹ Î¼ÏŒÎ½Î¿ Ï„Î¿Î½ Î±ÏÎ¹Î¸Î¼ÏŒ, Î±Î»Î»Î¬ ÎºÎ±Î¹ Ï„Î· ÏƒÎ·Î¼Î±ÏƒÎ¯Î± Ï„Ï‰Î½ ÏƒÏ…Î½Î´Î­ÏƒÎµÏÎ½ Ï„Î¿Ï….</i></p>
                </div>
                <div class="stat-section">
                    <h3>ğŸ¤ Î ÏÎ¿Ï„ÎµÎ¹Î½ÏŒÎ¼ÎµÎ½ÎµÏ‚ ÎÎ­ÎµÏ‚ Î£Ï…Î½Î´Î­ÏƒÎµÎ¹Ï‚</h3>
                    ${suggestions.join('<br>')}
                </div>
            `;
        }

        function formatMap(mapObj) {
            return Object.entries(mapObj)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([node, val]) => `${node}: ${val.toFixed(3)}`)
                .join('<br>');
        }

        function calcCloseness() {
            const result = {};
            nodes.forEach(n => {
                let totalDist = 0;
                nodes.forEach(m => {
                    if (n.id !== m.id) {
                        totalDist += shortestPathLength(n.id, m.id);
                    }
                });
                result[n.label] = totalDist > 0 ? (1 / totalDist) : 0;
            });
            return result;
        }

        function calcBetweenness() {
            const result = {};
            nodes.forEach(n => result[n.label] = 0);

            nodes.forEach(s => {
                nodes.forEach(t => {
                    if (s.id !== t.id) {
                        const path = [s.id, t.id]; // Î±Ï€Î»Î® ÎµÎºÎ´Î¿Ï‡Î®
                        path.forEach(mid => {
                            if (mid !== s.id && mid !== t.id) {
                                result[nodes.get(mid).label] += 1;
                            }
                        });
                    }
                });
            });
            return result;
        }

        function calcPageRank(d = 0.85, iterations = 20) {
            const result = {};
            const N = nodes.length;
            nodes.forEach(n => result[n.label] = 1 / N);

            for (let i = 0; i < iterations; i++) {
                const newRank = {};
                nodes.forEach(n => newRank[n.label] = (1 - d) / N);
                edges.forEach(e => {
                    const fromLabel = nodes.get(e.from).label;
                    const toLabel = nodes.get(e.to).label;
                    const outDegree = edges.get().filter(x => x.from === e.from).length;
                    if (outDegree > 0) {
                        newRank[toLabel] += d * (result[fromLabel] / outDegree);
                    }
                });
                Object.assign(result, newRank);
            }
            return result;
        }

        function shortestPathLength(from, to) {
            const visited = new Set();
            const queue = [{ node: from, dist: 0 }];
            while (queue.length > 0) {
                const { node, dist } = queue.shift();
                if (node === to) return dist;
                if (!visited.has(node)) {
                    visited.add(node);
                    edges.get().forEach(e => {
                        if (e.from === node) queue.push({ node: e.to, dist: dist + 1 });
                        if (e.to === node) queue.push({ node: e.from, dist: dist + 1 });
                    });
                }
            }
            return Infinity;
        }

        function suggestFriends(nodeMap, edges) {
            const neighbors = new Map();
            edges.forEach(edge => {
                if (!neighbors.has(edge.from)) neighbors.set(edge.from, new Set());
                if (!neighbors.has(edge.to)) neighbors.set(edge.to, new Set());
                neighbors.get(edge.from).add(edge.to);
                neighbors.get(edge.to).add(edge.from);
            });

            const suggestions = [];
            nodes.forEach(node1 => {
                nodes.forEach(node2 => {
                    if (node1.id !== node2.id && !neighbors.get(node1.id)?.has(node2.id)) {
                        const common = intersection(neighbors.get(node1.id) || new Set(), neighbors.get(node2.id) || new Set());
                        if (common.size > 0) {
                            suggestions.push(`${node1.label} â†” ${node2.label} (ÎºÎ¿Î¹Î½Î­Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎµÎ¹Ï‚: ${common.size})`);
                        }
                    }
                });
            });
            return suggestions.slice(0, 5);
        }

        function intersection(setA, setB) {
            const result = new Set();
            setA.forEach(item => { if (setB.has(item)) result.add(item); });
            return result;
        }
    </script>
</body>
</html>
