<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Analyzer</title>
    <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            text-align: center;
        }
        #inputData {
            width: 400px;
            height: 150px;
            padding: 10px;
            margin: 10px;
            font-size: 16px;
        }
        #submitBtn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #mynetwork {
            width: 100%;
            height: 600px;
            border: 1px solid lightgray;
            margin-top: 20px;
        }
        #output {
            margin-top: 20px;
            font-size: 16px;
            text-align: left;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }
        .stat-section {
            margin-bottom: 25px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 15px;
        }
        h3 {
            color: #2a4d69;
        }
    </style>
</head>
<body>
    <h1>Network Analyzer</h1>
    <textarea id="inputData" placeholder="Εισάγετε δεδομένα σχέσεων (π.χ. ΟΝΟΜΑ1,ΟΝΟΜΑ2,ΣΧΕΣΗ,ΒΑΡΟΣ)"></textarea><br>
    <button id="submitBtn">Ανάλυση & Οπτικοποίηση</button>
    <div id="mynetwork"></div>
    <div id="output"></div>

    <script>
        const inputData = document.getElementById('inputData');
        const submitBtn = document.getElementById('submitBtn');
        const output = document.getElementById('output');
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let network;

        submitBtn.addEventListener('click', function() {
            const data = inputData.value.trim();
            if (data) {
                processNetwork(data);
            } else {
                output.textContent = "Παρακαλώ εισάγετε δεδομένα!";
            }
        });

        function processNetwork(data) {
            nodes.clear();
            edges.clear();
            const nodeMap = new Map();
            const relationships = data.split('\n').map(line => line.split(',').map(part => part.trim()));

            relationships.forEach(([from, to, type, weight]) => {
                if (from && to && weight) {
                    if (!nodeMap.has(from)) {
                        nodeMap.set(from, nodes.length);
                        nodes.add({ id: nodeMap.get(from), label: from, group: 0 });
                    }
                    if (!nodeMap.has(to)) {
                        nodeMap.set(to, nodes.length);
                        nodes.add({ id: nodeMap.get(to), label: to, group: 0 });
                    }
                    edges.add({
                        from: nodeMap.get(from),
                        to: nodeMap.get(to),
                        label: `${type} (${parseFloat(weight).toFixed(2)})`,
                        width: parseFloat(weight) * 3
                    });
                }
            });

            const communities = detectCommunities(nodeMap, edges);
            nodes.update(communities);

            const container = document.getElementById('mynetwork');
            const networkData = { nodes: nodes, edges: edges };
            const options = {
                nodes: { shape: 'dot', size: 20, font: { size: 16, face: 'Arial' } },
                edges: { font: { size: 12 }, color: 'gray' },
                physics: { forceAtlas2Based: { gravitationalConstant: -50, centralGravity: 0.01 } },
                layout: { improvedLayout: true }
            };
            network = new vis.Network(container, networkData, options);

            analyzeNetwork(nodeMap, edges);
        }

        function detectCommunities(nodeMap, edges) {
            const communityMap = new Map();
            let group = 0;
            const visited = new Set();

            edges.forEach(edge => {
                const from = edge.from;
                const to = edge.to;
                if (!visited.has(from) && !visited.has(to)) {
                    group++;
                    visited.add(from);
                    visited.add(to);
                    communityMap.set(from, group);
                    communityMap.set(to, group);
                } else if (visited.has(from)) {
                    communityMap.set(to, communityMap.get(from));
                    visited.add(to);
                } else if (visited.has(to)) {
                    communityMap.set(from, communityMap.get(to));
                    visited.add(from);
                }
            });

            return nodes.get().map(node => ({
                id: node.id,
                group: communityMap.get(node.id) || 0
            }));
        }

        function analyzeNetwork(nodeMap, edges) {
            const nodeCount = nodes.length;
            const edgeCount = edges.length;
            const degreeCentrality = new Map();

            edges.forEach(edge => {
                degreeCentrality.set(edge.from, (degreeCentrality.get(edge.from) || 0) + 1);
                degreeCentrality.set(edge.to, (degreeCentrality.get(edge.to) || 0) + 1);
            });

            const density = (2 * edgeCount) / (nodeCount * (nodeCount - 1));
            const topNodes = Array.from(degreeCentrality.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([id, degree]) => `${nodes.get(id).label}: ${degree}`);

            const closeness = calcCloseness();
            const betweenness = calcBetweenness();
            const pagerank = calcPageRank();

            const suggestions = suggestFriends(nodeMap, edges);

            output.innerHTML = `
                <div class="stat-section">
                    <h3>📊 Βασικά Στατιστικά</h3>
                    Κόμβοι: ${nodeCount}<br>
                    Συνδέσεις: ${edgeCount}<br>
                    Πυκνότητα Δικτύου: ${density.toFixed(4)}<br>
                </div>
                <div class="stat-section">
                    <h3>🌟 Οι 5 Πιο Κεντρικοί Κόμβοι (Degree)</h3>
                    ${topNodes.join('<br>')}
                    <p><i>Degree δείχνει πόσες άμεσες συνδέσεις έχει ένας κόμβος. Όσο μεγαλύτερο, τόσο πιο «δημοφιλής» ο κόμβος.</i></p>
                </div>
                <div class="stat-section">
                    <h3>🔀 Betweenness Centrality</h3>
                    ${formatMap(betweenness)}
                    <p><i>Betweenness δείχνει ποιοι κόμβοι λειτουργούν ως «γέφυρες» ανάμεσα σε ομάδες. Υψηλή τιμή σημαίνει ότι ο κόμβος ελέγχει τη ροή πληροφορίας.</i></p>
                </div>
                <div class="stat-section">
                    <h3>📍 Closeness Centrality</h3>
                    ${formatMap(closeness)}
                    <p><i>Closeness δείχνει πόσο γρήγορα μπορεί ένας κόμβος να φτάσει όλους τους άλλους. Όσο πιο υψηλό, τόσο πιο «κεντρικός» στο δίκτυο.</i></p>
                </div>
                <div class="stat-section">
                    <h3>🏆 PageRank</h3>
                    ${formatMap(pagerank)}
                    <p><i>PageRank μετρά τη «σημασία» ενός κόμβου, λαμβάνοντας υπόψη όχι μόνο τον αριθμό, αλλά και τη σημασία των συνδέσεών του.</i></p>
                </div>
                <div class="stat-section">
                    <h3>🤝 Προτεινόμενες Νέες Συνδέσεις</h3>
                    ${suggestions.join('<br>')}
                </div>
            `;
        }

        function formatMap(mapObj) {
            return Object.entries(mapObj)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([node, val]) => `${node}: ${val.toFixed(3)}`)
                .join('<br>');
        }

        function calcCloseness() {
            const result = {};
            nodes.forEach(n => {
                let totalDist = 0;
                nodes.forEach(m => {
                    if (n.id !== m.id) {
                        totalDist += shortestPathLength(n.id, m.id);
                    }
                });
                result[n.label] = totalDist > 0 ? (1 / totalDist) : 0;
            });
            return result;
        }

        function calcBetweenness() {
            const result = {};
            nodes.forEach(n => result[n.label] = 0);

            nodes.forEach(s => {
                nodes.forEach(t => {
                    if (s.id !== t.id) {
                        const path = [s.id, t.id]; // απλή εκδοχή
                        path.forEach(mid => {
                            if (mid !== s.id && mid !== t.id) {
                                result[nodes.get(mid).label] += 1;
                            }
                        });
                    }
                });
            });
            return result;
        }

        function calcPageRank(d = 0.85, iterations = 20) {
            const result = {};
            const N = nodes.length;
            nodes.forEach(n => result[n.label] = 1 / N);

            for (let i = 0; i < iterations; i++) {
                const newRank = {};
                nodes.forEach(n => newRank[n.label] = (1 - d) / N);
                edges.forEach(e => {
                    const fromLabel = nodes.get(e.from).label;
                    const toLabel = nodes.get(e.to).label;
                    const outDegree = edges.get().filter(x => x.from === e.from).length;
                    if (outDegree > 0) {
                        newRank[toLabel] += d * (result[fromLabel] / outDegree);
                    }
                });
                Object.assign(result, newRank);
            }
            return result;
        }

        function shortestPathLength(from, to) {
            const visited = new Set();
            const queue = [{ node: from, dist: 0 }];
            while (queue.length > 0) {
                const { node, dist } = queue.shift();
                if (node === to) return dist;
                if (!visited.has(node)) {
                    visited.add(node);
                    edges.get().forEach(e => {
                        if (e.from === node) queue.push({ node: e.to, dist: dist + 1 });
                        if (e.to === node) queue.push({ node: e.from, dist: dist + 1 });
                    });
                }
            }
            return Infinity;
        }

        function suggestFriends(nodeMap, edges) {
            const neighbors = new Map();
            edges.forEach(edge => {
                if (!neighbors.has(edge.from)) neighbors.set(edge.from, new Set());
                if (!neighbors.has(edge.to)) neighbors.set(edge.to, new Set());
                neighbors.get(edge.from).add(edge.to);
                neighbors.get(edge.to).add(edge.from);
            });

            const suggestions = [];
            nodes.forEach(node1 => {
                nodes.forEach(node2 => {
                    if (node1.id !== node2.id && !neighbors.get(node1.id)?.has(node2.id)) {
                        const common = intersection(neighbors.get(node1.id) || new Set(), neighbors.get(node2.id) || new Set());
                        if (common.size > 0) {
                            suggestions.push(`${node1.label} ↔ ${node2.label} (κοινές συνδέσεις: ${common.size})`);
                        }
                    }
                });
            });
            return suggestions.slice(0, 5);
        }

        function intersection(setA, setB) {
            const result = new Set();
            setA.forEach(item => { if (setB.has(item)) result.add(item); });
            return result;
        }
    </script>
</body>
</html>
