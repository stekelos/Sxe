<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Analyzer</title>
    <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        #inputData { width: 400px; height: 150px; padding: 10px; margin: 10px; font-size: 16px; }
        #submitBtn { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        #mynetwork { width: 100%; height: 600px; border: 1px solid lightgray; margin-top: 20px; }
        #output { margin-top: 20px; font-size: 16px; text-align: left; max-width: 1000px; margin-left: auto; margin-right: auto; }
        canvas { margin-top: 30px; }
        table { border-collapse: collapse; width: 100%; margin-top: 15px; font-size: 14px; }
        th, td { border: 1px solid gray; padding: 6px 8px; text-align: center; }
        th { background: #f0f0f0; }
        .legend { margin-top: 15px; font-size: 14px; }
    </style>
</head>
<body>
    <h1>Network Analyzer</h1>
    <textarea id="inputData" placeholder="ΟΝΟΜΑ1,ΟΝΟΜΑ2,ΣΧΕΣΗ,ΒΑΡΟΣ"></textarea><br>
    <button id="submitBtn">Ανάλυση & Οπτικοποίηση</button>
    <div id="mynetwork"></div>
    <div id="output"></div>
    <canvas id="chartCentrality"></canvas>
    <div class="legend">🔴 Υψηλή Σημασία | 🟠 Μεσαία | 🟢 Χαμηλή</div>

    <script>
        const inputData = document.getElementById('inputData');
        const submitBtn = document.getElementById('submitBtn');
        const output = document.getElementById('output');
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let network;

        submitBtn.addEventListener('click', () => {
            const data = inputData.value.trim();
            if (data) processNetwork(data);
            else output.textContent = "Παρακαλώ εισάγετε δεδομένα!";
        });

        function processNetwork(data) {
            nodes.clear(); edges.clear();
            const nodeMap = new Map();
            const relationships = data.split('\n').map(line => line.split(',').map(p => p.trim()));
            
            relationships.forEach(([from, to, type, weight]) => {
                if (from && to && weight) {
                    if (!nodeMap.has(from)) { nodeMap.set(from, nodes.length); nodes.add({ id: nodeMap.get(from), label: from }); }
                    if (!nodeMap.has(to)) { nodeMap.set(to, nodes.length); nodes.add({ id: nodeMap.get(to), label: to }); }
                    edges.add({ from: nodeMap.get(from), to: nodeMap.get(to), label: `${type} (${parseFloat(weight).toFixed(2)})`, width: parseFloat(weight) * 3 });
                }
            });

            const container = document.getElementById('mynetwork');
            const networkData = { nodes: nodes, edges: edges };
            network = new vis.Network(container, networkData, { physics: { stabilization: true } });

            analyzeNetwork();
        }

        function analyzeNetwork() {
            const nodeIds = nodes.getIds();
            const adjacency = buildAdjacency(nodeIds);

            // Υπολογισμοί
            const degree = calcDegree(adjacency);
            const betweenness = calcBetweenness(adjacency);
            const closeness = calcCloseness(adjacency);
            const pagerank = calcPageRank(adjacency);

            // Χρωματισμός με βάση το PageRank
            const prValues = Object.values(pagerank);
            const minPR = Math.min(...prValues);
            const maxPR = Math.max(...prValues);
            nodeIds.forEach(id => {
                let score = (pagerank[id] - minPR) / (maxPR - minPR + 1e-9); // scale 0-1
                nodes.update({ id: id, color: { background: getColor(score), border: '#333' } });
            });

            // Πίνακας μετρικών
            let html = `<h3>📊 Αναλυτικά Στατιστικά Κόμβων</h3>
                        <table>
                        <tr><th>Κόμβος</th><th>Degree</th><th>Betweenness</th><th>Closeness</th><th>PageRank</th></tr>`;
            nodeIds.forEach(id => {
                html += `<tr>
                    <td>${nodes.get(id).label}</td>
                    <td>${degree[id]}</td>
                    <td>${betweenness[id].toFixed(2)}</td>
                    <td>${closeness[id].toFixed(2)}</td>
                    <td>${pagerank[id].toFixed(3)}</td>
                </tr>`;
            });
            html += `</table>`;
            output.innerHTML = html;

            // Διάγραμμα
            drawChart(nodeIds.map(id => nodes.get(id).label), degree, betweenness, closeness, pagerank);
        }

        function buildAdjacency(nodeIds) {
            const adj = {};
            nodeIds.forEach(id => adj[id] = []);
            edges.forEach(e => { adj[e.from].push(e.to); adj[e.to].push(e.from); });
            return adj;
        }

        function calcDegree(adj) {
            const degree = {};
            for (let n in adj) degree[n] = adj[n].length;
            return degree;
        }

        function calcBetweenness(adj) {
            const nodes = Object.keys(adj);
            const betweenness = {}; nodes.forEach(n => betweenness[n] = 0);

            nodes.forEach(s => {
                let stack = [];
                let pred = {}; nodes.forEach(w => pred[w] = []);
                let sigma = {}; nodes.forEach(t => sigma[t] = 0); sigma[s] = 1;
                let dist = {}; nodes.forEach(t => dist[t] = -1); dist[s] = 0;

                let queue = [s];
                while (queue.length > 0) {
                    let v = queue.shift();
                    stack.push(v);
                    adj[v].forEach(w => {
                        if (dist[w] < 0) { dist[w] = dist[v] + 1; queue.push(w); }
                        if (dist[w] === dist[v] + 1) { sigma[w] += sigma[v]; pred[w].push(v); }
                    });
                }
                let delta = {}; nodes.forEach(v => delta[v] = 0);
                while (stack.length > 0) {
                    let w = stack.pop();
                    pred[w].forEach(v => { delta[v] += (sigma[v]/sigma[w]) * (1+delta[w]); });
                    if (w !== s) betweenness[w] += delta[w];
                }
            });
            return betweenness;
        }

        function calcCloseness(adj) {
            const nodes = Object.keys(adj);
            const closeness = {};
            nodes.forEach(n => {
                let dist = bfsDistances(adj, n);
                let sum = Object.values(dist).reduce((a,b)=>a+b,0);
                closeness[n] = sum>0 ? (nodes.length-1)/sum : 0;
            });
            return closeness;
        }

        function bfsDistances(adj, start) {
            let dist = {}; Object.keys(adj).forEach(n => dist[n] = Infinity);
            dist[start] = 0; let queue = [start];
            while (queue.length) {
                let v = queue.shift();
                adj[v].forEach(w => {
                    if (dist[w] === Infinity) { dist[w] = dist[v]+1; queue.push(w); }
                });
            }
            return dist;
        }

        function calcPageRank(adj, d=0.85, iterations=20) {
            const nodes = Object.keys(adj);
            let pr = {}; nodes.forEach(n => pr[n] = 1/nodes.length);
            for (let i=0; i<iterations; i++) {
                let newPr = {}; nodes.forEach(n => newPr[n] = (1-d)/nodes.length);
                nodes.forEach(n => {
                    if (adj[n].length === 0) return;
                    let share = pr[n]/adj[n].length;
                    adj[n].forEach(m => { newPr[m] += d*share; });
                });
                pr = newPr;
            }
            return pr;
        }

        function drawChart(labels, degree, betweenness, closeness, pagerank) {
            const ctx = document.getElementById('chartCentrality').getContext('2d');
            new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Degree', data: labels.map((_,i)=>degree[i]), fill: true },
                        { label: 'Betweenness', data: labels.map((_,i)=>betweenness[i].toFixed(2)), fill: true },
                        { label: 'Closeness', data: labels.map((_,i)=>closeness[i].toFixed(2)), fill: true },
                        { label: 'PageRank', data: labels.map((_,i)=>pagerank[i].toFixed(3)), fill: true }
                    ]
                }
            });
        }

        function getColor(score) {
            // score 0 = πράσινο, 1 = κόκκινο
            const r = Math.floor(255 * score);
            const g = Math.floor(200 * (1 - score));
            return `rgb(${r},${g},80)`;
        }
    </script>
</body>
</html>
